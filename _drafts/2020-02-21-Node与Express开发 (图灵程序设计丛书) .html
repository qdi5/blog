<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                              "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" >
<html xmlns="http://www.w3.org/TR/1999/REC-html-in-xml" xml:lang="en"
	lang="en">
	<head>
                <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
                <!-- HTML5 -->
                <meta charset="UTF-8"/>
		<style type="text/css">
                    .bodyContainer {
    font-family: Arial, Helvetica, sans-serif;
    text-align: center;
    padding-left: 32px;
    padding-right: 32px;
}

.notebookFor {
    font-size: 18px;
    font-weight: 700;
    text-align: center;
    color: rgb(119, 119, 119);
    margin: 24px 0px 0px;
    padding: 0px;
}

.bookTitle {
    font-size: 32px;
    font-weight: 700;
    text-align: center;
    color: #333333;
    margin-top: 22px;
    padding: 0px;
}

.authors {
    font-size: 13px;
    font-weight: 700;
    text-align: center;
    color: rgb(119, 119, 119);
    margin-top: 22px;
    margin-bottom: 24px; 
    padding: 0px;
}

.citation {
    font-size: 16px;
    font-weight: 500;
    text-align: center;
    color: #333333;
    margin-top: 22px;
    margin-bottom: 24px;
    padding: 0px;
}

.sectionHeading {
    font-size: 24px;
    font-weight: 700;
    text-align: left;
    color: #333333;
    margin-top: 24px;
    padding: 0px;
}

.noteHeading {
    font-size: 18px;
    font-weight: 700;
    text-align: left;
    color: #333333;
    margin-top: 20px;
    padding: 0px;
}

.noteText {
    font-size: 18px;
    font-weight: 500;
    text-align: left;
    color: #333333;
    margin: 2px 0px 0px;
    padding: 0px;
}

.highlight_blue {
    color: rgb(178, 205, 251);
}

.highlight_orange {
    color: #ffd7ae;
}

.highlight_pink {
    color: rgb(255, 191, 206);
}

.highlight_yellow {
    color: rgb(247, 206, 0);
}

.notebookGraphic {
    margin-top: 10px;
    text-align: left;
}

.notebookGraphic img {
    -o-box-shadow:      0px 0px 5px #888;
    -icab-box-shadow:   0px 0px 5px #888;
    -khtml-box-shadow:  0px 0px 5px #888;
    -moz-box-shadow:    0px 0px 5px #888;
    -webkit-box-shadow: 0px 0px 5px #888;
    box-shadow:         0px 0px 5px #888; 
    max-width: 100%;
    height: auto;
}

hr {
    border: 0px none;
    height: 1px;
    background: none repeat scroll 0% 0% rgb(221, 221, 221);
}

		</style>
		<script type="text/javascript">
		    
		</script>
		<title></title>
	</head>
    <body>
        <div class="bodyContainer">
            <div class="notebookFor">
笔记本
</div>
<div class="bookTitle">
Node与Express开发 (图灵程序设计丛书)
</div>
<div class="authors">
Ethan Brown
</div>
<div class="citation">
Citation (芝加哥风格): Brown, Ethan. <i>Node与Express开发 (图灵程序设计丛书)</i>. 人民邮电出版社, 2015. Kindle edition.
</div>
<hr />

            <div class="sectionHeading">
1.6　Node的生态系统
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 5 页
</div>
<div class="noteText">
Node开发的出现带动了一种新式的数据库存储方式，这种方式被称为“ NoSQL数据库”。用否定的方式来下定义有时并不恰当，所以我们更准确地称之为“文档数据库”或“键/值对数据库”。
</div>
<div class="noteHeading">
笔记 -  第 6 页
</div>
<div class="noteText">
Nosql 数据库
</div>
<div class="sectionHeading">
2.2　使用终端
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 9 页
</div>
<div class="noteText">
我推荐你安装 Console2（ http:// sourceforge. net/ projects/ console/）或 ConEmu（ https:// github. com/ Maximus5/ ConEmu）这些更精致的控制台。
</div>
<div class="noteHeading">
笔记 -  第 9 页
</div>
<div class="noteText">
精致的控制台
</div>
<div class="sectionHeading">
2.5.2　事件驱动编程
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 13 页
</div>
<div class="noteText">
Node的核心理念是事件驱动编程。这对
</div>
<div class="noteHeading">
笔记 -  第 13 页
</div>
<div class="noteText">
事件驱动
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 13 页
</div>
<div class="noteText">
HTTP请求就是要处理的事件。 http. createServer方法将函数作为一个参数，每次有 HTTP请求发送过来就会调用那个函数。
</div>
<div class="noteHeading">
笔记 -  第 13 页
</div>
<div class="noteText">
服务端事件的简单理解
</div>
<div class="sectionHeading">
2.5.3　路由
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 13 页
</div>
<div class="noteText">
路由是指向客户端提供它所发出的请求内容的机制。对基于 Web的客户端/服务器端程序而言，客户端在 URL中指明它想要的内容，具体来说就是路径和查询字符串（
</div>
<div class="noteHeading">
笔记 -  第 13 页
</div>
<div class="noteText">
路由
</div>
<div class="sectionHeading">
2.5.4　静态资源服务
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 15 页
</div>
<div class="noteText">
￼__ dirname会被解析为正在执行的脚本所在的目录。所以如果你的脚本放在/ home/ sites/ app. js中，则__ dirname会被解析为/ home/ sites。
</div>
<div class="noteHeading">
笔记 -  第 15 页
</div>
<div class="noteText">
__dirname 正在运行的脚本的目录
</div>
<div class="sectionHeading">
3.3　初始步骤
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 20 页
</div>
<div class="noteText">
指定程序端口的方式： app. set( port, process. env. PORT | | 3000)。这样我们可以在启动服务器前通过设置环境变量覆盖端口。如果你在运行这个案例时发现它监听的不是 3000端口，检查一下是否设置了环境变量 PORT。
</div>
<div class="noteHeading">
笔记 -  第 20 页
</div>
<div class="noteText">
设置启动端口
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 20 页
</div>
<div class="noteText">
Express文档中写的是 app. VERB。这并不意味着存在一个叫 VERB的方法，它是用来指代 HTTP动词的（最常见的是“ get”和“ post”）。这个方法有两个参数：一个路径和一个函数。
</div>
<div class="noteHeading">
笔记 -  第 20 页
</div>
<div class="noteText">
Express 处理get 或 post 请求
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 20 页
</div>
<div class="noteText">
app. VERB帮我们做了很多工作：它默认忽略了大小写或反斜杠，并且在进行匹配时也不考虑查询字符串。
</div>
<div class="noteHeading">
笔记 -  第 20 页
</div>
<div class="noteText">
App.get 或post 的默认行为
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 20 页
</div>
<div class="noteText">
res. set和 res. status替换了 Node的 res. writeHead。 Express还提供了一个 res. type方法，可以方便地设置响应头 Content- Type。
</div>
<div class="noteHeading">
笔记 -  第 20 页
</div>
<div class="noteText">
Express 与node 不同的 api 
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 21 页
</div>
<div class="noteText">
app. use是 Express添加中间件的一种方法。
</div>
<div class="noteHeading">
笔记 -  第 21 页
</div>
<div class="noteText">
App.use
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 21 页
</div>
<div class="noteText">
在 Express中，路由和中间件的添加顺序至关重要。如果我们把 404处理器放在所有路由上面，那首页和关于页面就不能用了，访问这些 URL得到的都是 404。
</div>
<div class="noteHeading">
笔记 -  第 21 页
</div>
<div class="noteText">
Express 中路由和中间件的添加顺序非常重要
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 21 页
</div>
<div class="noteText">
Express能根据回调函数中参数的个数区分 404和 500处理器。
</div>
<div class="noteHeading">
笔记 -  第 21 页
</div>
<div class="noteText">
Express 自动识别404或500处理
</div>
<div class="sectionHeading">
3.3.1　视图和布局
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 21 页
</div>
<div class="noteText">
视图与静态资源（比如图片或 CSS文件）的区别是它不一定是静态的： HTML可以动态构建，为每个请求提供定制的页面。
</div>
<div class="noteHeading">
笔记 -  第 21 页
</div>
<div class="noteText">
试图与静态资源的区别
</div>
<div class="sectionHeading">
3.3.2　视图和静态文件
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 24 页
</div>
<div class="noteText">
static中间件可以将一个或多个目录指派为包含静态资源的目录，其中的资源不经过任何特殊处理直接发送到客户端。你可以在其中放图片、 CSS文件、客户端 JavaScript文件之类的资源。
</div>
<div class="noteHeading">
笔记 -  第 24 页
</div>
<div class="noteText">
Static 中间件
</div>
<div class="sectionHeading">
3.3.3　视图中的动态内容
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 25 页
</div>
<div class="noteText">
res. render(' about', { fortune: randomFortune });
</div>
<div class="noteHeading">
笔记 -  第 25 页
</div>
<div class="noteText">
Render 后面是可以直接发送数据的
</div>
<div class="sectionHeading">
4.2　版本控制
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 27 页
</div>
<div class="noteText">
如果你不了解 Git，建议你看一下 Jon Loeliger的 Version Control with Git (O' Reilly， http:// shop. oreilly. com/ product/ 9780596520137. do）。另外， Code School也有很好的 Git入门课程（ https:// try. github. io/）。
</div>
<div class="noteHeading">
笔记 -  第 27 页
</div>
<div class="noteText">
Git 的学习教程
</div>
<div class="sectionHeading">
4.3.1　如果你要自己动手
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 28 页
</div>
<div class="noteText">
gitignore文件中的条目也适用于子目录。所以如果你把* ~放在项目根目录下的. gitignore文件里，那么子目录里的所有这种备份文件都会被忽略。
</div>
<div class="noteHeading">
笔记 -  第 28 页
</div>
<div class="noteText">
.gitignore 文件规则
</div>
<div class="sectionHeading">
4.4　npm包
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 30 页
</div>
<div class="noteText">
package. json文件有双重作用：描述项目和列出依赖项。
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 30 页
</div>
<div class="noteText">
注意包版本号之前的插入符（ ^），这表明在下一个主要版本号之前，所有以指定版本号开始的版本都能用。比如说，这个 package. json中的 Express，从 4. 0. 0开始都能用，所以 4. 0. 1和 4. 9. 9都可以，但 3. 4. 7不行， 5. 0. 0也不行。
</div>
<div class="noteHeading">
笔记 -  第 30 页
</div>
<div class="noteText">
package 的^的意义
</div>
<div class="sectionHeading">
4.5　项目元数据
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 31 页
</div>
<div class="noteText">
Markdown文档（ http:// daringfireball. net/ projects/ markdown/）。
</div>
<div class="noteHeading">
笔记 -  第 31 页
</div>
<div class="noteText">
Markdown 文档
</div>
<div class="sectionHeading">
5.1　QA：值得吗
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 34 页
</div>
<div class="noteText">
在 Web开发中，质量可以分解为四个维度：到达率到达率是指产品的市场普及程度，即查看网站或使用服务的人数。到达率和盈利能力是正相关关系：访问网站的人越多，购买产品或服务的人就越多。从开发的角度来看，搜索引擎优化（ SEO）对到达率的影响最大，所以我们会在 QA方案里包含 SEO。功能人们一旦访问了你的网站或使用了你的服务，能否把用户留下很大程度上取决于网站功能的质量：一个能像广告宣传那样工作的网站更有可能吸引回头客。与其他几个维度不同，功能测试一般都可以自动执行。可用性功能关心的是功能的正确性，而可用性评估的是人机交互（ HCI）。根本问题是：“这个功能是以对目标受众有用的方式交付的吗？”这个问题经常被换成“它易用吗？”，尽管追求易用性经常跟灵活性或能力是相对的：程序员眼中的“容易”可能跟不懂技术的用户眼中的“容易”不一样。换句话说，评估可用性时你必须考虑目标受众。因为可用性评估的根本输入是用户，所以可用性评估一般无法自动完成。然而，你的 QA方案中应该包含用户测试。审美审美是四个维度中最主观的，因此也是跟开发最不相关的一个维度。尽管跟网站审美相关的开发问题没有几个，但 QA方案中还是应该包括网站审美的常规评审。把网站展示给有代表性的样本受众，看他们是否觉得已经过时，或者是不是没能激起你所期望的响应。记住，审美具有时间敏感性（审美标准会随着时间而发生变化），并且因人而异（受到某一受众喜爱的东西可能完全激不起其他受众的兴趣）。
</div>
<div class="noteHeading">
笔记 -  第 35 页
</div>
<div class="noteText">
Web 开发质量衡量的四个标准
</div>
<div class="sectionHeading">
5.3　测试的类型
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 35 页
</div>
<div class="noteText">
单元测试的粒度非常细，是对单个组件进行测试以确保其功能正确，而集成测试是对多个组件甚至整个系统之间的交互进行测试。
</div>
<div class="noteHeading">
笔记 -  第 35 页
</div>
<div class="noteText">
单元测试和集成测试
</div>
<div class="sectionHeading">
5.4　QA技术概览
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 35 页
</div>
<div class="noteText">
页面测试
</div>
<div class="noteHeading">
笔记 -  第 35 页
</div>
<div class="noteText">
测试内容一
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 36 页
</div>
<div class="noteText">
跨页测试跨页测试是对从一个页面转到另一个页面的功能的测试。比如电子商务网站上的结账功能，通常要跨越多个页面。因为这种测试会涉及多个组件，所以一般被当作集成测试。这个测试用的是 Zombie. js。
</div>
<div class="noteHeading">
笔记 -  第 36 页
</div>
<div class="noteText">
测试内容二,跨页测试
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 36 页
</div>
<div class="noteText">
逻辑测试逻辑测试会对逻辑域进行单元和集成测试。它只会测试 JavaScript，跟所有表示功能分开。
</div>
<div class="noteHeading">
笔记 -  第 36 页
</div>
<div class="noteText">
测试内容三:逻辑测试
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 36 页
</div>
<div class="noteText">
去毛去毛不是要找错误，而是要找潜在的错误。去毛的一般概念是找出可能有错误的区域，或者可能在将来导致错误发生的问题代码。我们会用 JSHint做去毛。
</div>
<div class="noteHeading">
笔记 -  第 36 页
</div>
<div class="noteText">
测试内容四:去毛,检查未来可能出现的错误
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 36 页
</div>
<div class="noteText">
链接检查链接检查（确保你的网站上没有破损的链接）属于“唾手可得”的那一类测试。对简单的项目做链接检查看起来可能没有必要，但简单项目也会发展成复杂项目，破损的链接也将会出现。越早把链接检查放到 QA过程里越好。链接检查属于单元测试（链接有效或者无效）。我们会用 LinkChecker做链接检查。
</div>
<div class="noteHeading">
笔记 -  第 36 页
</div>
<div class="noteText">
测试内容五:链接检查
</div>
<div class="sectionHeading">
5.5　运行你的服务器
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 36 页
</div>
<div class="noteText">
选择。如果你发现自己在修改 JavaScript时会忘记重启服务器，或许你希望找一个监控工具，在它发现 JavaScript被修改后会自动重启服务器。 nodemon（ https:// npmjs. org/ package/ nodemon）非常受欢迎，
</div>
<div class="noteHeading">
笔记 -  第 36 页
</div>
<div class="noteText">
监控Node
</div>
<div class="sectionHeading">
5.6　页面测试
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 36 页
</div>
<div class="noteText">
我们用的是-- save- dev而不是-- save，这是告诉 npm要把这个包放在开发依赖项中，不要放在运行时依赖项里。这样当我们部署网站的现场实例时，可以减少项目的依赖项。
</div>
<div class="noteHeading">
笔记 -  第 36 页
</div>
<div class="noteText">
--save-dev 安装开发时依赖
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 37 页
</div>
<div class="noteText">
测试通常需要一个 assert（或 expect）函数。 Node框架中有这个函数，但浏览器中没有，所以我们要用 Chai断言库：
</div>
<div class="noteHeading">
笔记 -  第 37 页
</div>
<div class="noteText">
chai 断言库
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 37 页
</div>
<div class="noteText">
res. locals对象是要传给视图的上下文的一部分（
</div>
<div class="noteHeading">
笔记 -  第 37 页
</div>
<div class="noteText">
Res.locals 
</div>
<div class="sectionHeading">
6.1　URL的组成部分
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 49 页
</div>
<div class="noteText">
如果不使用 80和 443端口，就需要一个大于 10231的端口号。通常使用容易记忆的端口号，如 3000、 8080或 8088。
</div>
<div class="noteHeading">
笔记 -  第 49 页
</div>
<div class="noteText">
端口使用范围
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 49 页
</div>
<div class="noteText">
查询字符串是一种键值对集合，是可选的。它以问号（?）开头，键值对则以与号（&）分隔开。所有的名称和值都必须是 URL编码的。对此， JavaScript提供了一个嵌入式的函数 encodeURIComponent来处理。例如，空格被加号（ +）替换。其他特殊字符被数字型字符替换。
</div>
<div class="noteHeading">
笔记 -  第 49 页
</div>
<div class="noteText">
查询字符串
</div>
<div class="sectionHeading">
6.4　响应报头
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 50 页
</div>
<div class="noteText">
内容类型头信息，它告诉浏览器正在被传输的内容类型（网页、图片、样式表、客户端脚本等）。特别要注意的是，不管 URL路径是什么，浏览器都根据内容类型报头处理信息。因此你可以通过一个叫作/ image. jpg的路径提供网页，也可以通过一个叫作/ text. html的路径提供图片。（这样做
</div>
<div class="noteHeading">
笔记 -  第 50 页
</div>
<div class="noteText">
浏览器根据内容报头信息来处理信息
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 50 页
</div>
<div class="noteText">
禁用 Express的 X- Powered- By头信息很
</div>
<div class="noteHeading">
笔记 -  第 50 页
</div>
<div class="noteText">
隐藏服务器报头信息的方法
</div>
<div class="sectionHeading">
6.5　互联网媒体类型
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 51 页
</div>
<div class="noteText">
内容类型报头信息极其重要，没有它，客户端很难判断如何渲染接收到的内容。内容类型报头就是一种互联网媒体类型，由一个类型、一个子类型以及可选的参数组成。例如， text/ html; charset = UTF- 8说明类型是 text，子类型是 html，字符编码是 UTF- 8。
</div>
<div class="noteHeading">
笔记 -  第 51 页
</div>
<div class="noteText">
内容类型报头信息
</div>
<div class="sectionHeading">
6.6　请求体
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 51 页
</div>
<div class="noteText">
除请求报头外，请求还有一个主体（就像作为实际内容返回的响应主体一样）。一般 GET请求没有主体内容，但 POST请求是有的。 POST请求体最常见的媒体类型是 application/ x- www- form- urlendcoded，是键值对集合的简单编码，用&分隔（基本上和查询字符串的格式一样）。如果 POST请求需要支持文件上传，则媒体类型是 multipart/ form- data，它是一种更为复杂的格式。最后是 AJAX请求，它可以使用 application/ json。
</div>
<div class="noteHeading">
笔记 -  第 51 页
</div>
<div class="noteText">
Http 的请求主体
</div>
<div class="sectionHeading">
6.7　参数
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 51 页
</div>
<div class="noteText">
“参数”这个词可以有很多种解释，它通常是困惑的源头。对于任何一个请求，参数可以来自查询字符串、会话（请求 cookies，详见第 9章）、请求体或指定的路由参数（详见第 14章）。
</div>
<div class="noteHeading">
笔记 -  第 51 页
</div>
<div class="noteText">
Http 请求参数
</div>
<div class="sectionHeading">
6.8　请求对象
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 52 页
</div>
<div class="noteText">
req. params一个数组，包含命名过的路由参数。
</div>
<div class="noteHeading">
笔记 -  第 52 页
</div>
<div class="noteText">
Req.ParAMAs
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 52 页
</div>
<div class="noteText">
req. query一个对象，包含以键值对存放的查询字符串参数（通常称为 GET请求参数）。
</div>
<div class="noteHeading">
笔记 -  第 52 页
</div>
<div class="noteText">
Req.query 
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 52 页
</div>
<div class="noteText">
req. body一个对象，包含 POST请求参数。这样命名是因为 POST请求参数在 REQUEST正文中传递，而不像查询字符串在 URL中传递。要使 req. body可用，需要中间件能够解析请求正文内容类型，
</div>
<div class="noteHeading">
笔记 -  第 52 页
</div>
<div class="noteText">
Req.body 
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 52 页
</div>
<div class="noteText">
req. route关于当前匹配路由的信息。主要用于路由调试。
</div>
<div class="noteHeading">
笔记 -  第 52 页
</div>
<div class="noteText">
Req.route 
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 52 页
</div>
<div class="noteText">
req. cookies/ req. singnedCookies一个对象，包含从客户端传递过来的 cookies值。详见第 9章。
</div>
<div class="noteHeading">
笔记 -  第 52 页
</div>
<div class="noteText">
Req.cookies
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 52 页
</div>
<div class="noteText">
req. headers从客户端接收到的请求报头。
</div>
<div class="noteHeading">
笔记 -  第 52 页
</div>
<div class="noteText">
Req.headers
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 52 页
</div>
<div class="noteText">
req. accepts([ types])一个简便的方法，用来确定客户端是否接受一个或一组指定的类型（可选类型可以是单个的 MIME类型，如 application/ json、一个逗号分隔集合或是一个数组）。写公共 API的人对该方法很感兴趣。假定浏览器默认始终接受 HTML。
</div>
<div class="noteHeading">
笔记 -  第 52 页
</div>
<div class="noteText">
Req.accepts
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 52 页
</div>
<div class="noteText">
req. ip客户端的 IP地址。
</div>
<div class="noteHeading">
笔记 -  第 52 页
</div>
<div class="noteText">
Req.ip
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 52 页
</div>
<div class="noteText">
req. path请求路径（不包含协议、主机、端口或查询字符串）。
</div>
<div class="noteHeading">
笔记 -  第 52 页
</div>
<div class="noteText">
Req.path 
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 52 页
</div>
<div class="noteText">
req. host一个简便的方法，用来返回客户端所报告的主机名。这些信息可以伪造，所以不应该用于安全目的。
</div>
<div class="noteHeading">
笔记 -  第 52 页
</div>
<div class="noteText">
Req.host 
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 53 页
</div>
<div class="noteText">
req. xhr一个简便属性，如果请求由 Ajax发起将会返回 true。
</div>
<div class="noteHeading">
笔记 -  第 53 页
</div>
<div class="noteText">
Req.xhr
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 53 页
</div>
<div class="noteText">
req. protocol用于标识请求的协议（ http或 https）。
</div>
<div class="noteHeading">
笔记 -  第 53 页
</div>
<div class="noteText">
Req.protocol
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 53 页
</div>
<div class="noteText">
req. secure一个简便属性，如果连接是安全的，将返回 true。等同于 req. protocol = = =' https'。
</div>
<div class="noteHeading">
笔记 -  第 53 页
</div>
<div class="noteText">
Req.secure 
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 53 页
</div>
<div class="noteText">
req. url/ req. originalUrl有点用词不当，这些属性返回了路径和查询字符串（它们不包含协议、主机或端口）。 req. url若是出于内部路由目的，则可以重写，但是 req. orginalUrl旨在保留原始请求和查询字符串。
</div>
<div class="noteHeading">
笔记 -  第 53 页
</div>
<div class="noteText">
Req.url 和req.originalUrl
</div>
<div class="sectionHeading">
6.9　响应对象
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 53 页
</div>
<div class="noteText">
res. status( code)设置 HTTP状态代码。 Express默认为 200（成功），所以你可以使用这个方法返回状态 404（页面不存在）或 500（服务器内部错误），或任何一个其他的状态码。对于重定向（状态码 301、 302、 303和 307），有一个更好的方法： redirect。
</div>
<div class="noteHeading">
笔记 -  第 53 页
</div>
<div class="noteText">
Res.status 
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 53 页
</div>
<div class="noteText">
res. cookie（ name, vaue,[ options]）, res. clearCookie( name,[ options])设置或清除客户端 cookies值。需要中间件支持，详见第 9章。
</div>
<div class="noteHeading">
笔记 -  第 53 页
</div>
<div class="noteText">
Res.cookies
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 53 页
</div>
<div class="noteText">
res. redirect([ status], url)重定向浏览器。默认重定向代码是 302（建立）。通常，你应尽量减少重定向，除非永久移动一个页面，这种情况应当使用代码 301（永久移动）。
</div>
<div class="noteHeading">
笔记 -  第 53 页
</div>
<div class="noteText">
Res.redirect
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 54 页
</div>
<div class="noteText">
res. send( body), res. send( status, body)向客户端发送响应及可选的状态码。 Express的默认内容类型是 text/ html。如果你想改为 text/ plain，需要在 res. send之前调用 res. set(' Content- Type',' text/ plain\')。如果 body是一个对象或一个数组，响应将会以 JSON发送（内容类型需要被正确设置），不过既然你想发送 JSON，我推荐你调用 res. json。
</div>
<div class="noteHeading">
笔记 -  第 54 页
</div>
<div class="noteText">
Res.send
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 54 页
</div>
<div class="noteText">
res. attachment([ filename]), res. download( path,[ filename],[ callback])这两种方法会将响应报头 Content- Disposition设为 attachment，这样浏览器就会选择下载而不是展现内容。你可以指定 filename给浏览器作为对用户的提示。用 res. download可以指定要下载的文件，而 res. attachment只是设置报头。另外，你还要将内容发送到客户端。
</div>
<div class="noteHeading">
笔记 -  第 54 页
</div>
<div class="noteText">
Res.attachment
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 54 页
</div>
<div class="noteText">
res. sendFile( path,[ option],[ callback])这个方法可根据路径读取指定文件并将内容发送到客户端。使用该方法很方便。使用静态中间件，并将发送到客户端的文件放在公共目录下，这很容易。然而，如果你想根据条件在相同的 URL下提供不同的资源，这个方法可以派上用场。
</div>
<div class="noteHeading">
笔记 -  第 54 页
</div>
<div class="noteText">
Res.sendFile
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 54 页
</div>
<div class="noteText">
res. locals, res. render( view,[ locals], callback) res. locals是一个对象，包含用于渲染视图的默认上下文。 res. render使用配置的模板引擎渲染视图（不能把 res. render的 locals参数与 res. locals混为一谈，上下文在 res. locals中会被重写，但在没有被重写的情况下仍然可用）。 res. render的默认响应代码为 200，使用 res. status可以指定一个不同的代码。视图渲染将在第 7章深入讨论。
</div>
<div class="noteHeading">
笔记 -  第 55 页
</div>
<div class="noteText">
Res.locals 和 res.render
</div>
<div class="sectionHeading">
6.10　获取更多信息
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 55 页
</div>
<div class="noteText">
如果你需要的信息没在文档中，有时就不得不深入研究 Express源码（ https:// github. com/ visionmedia/ express/ tree/ master）。我鼓励你这么做，它并没有想象中那么可怕。下面是 Express源码的路径说明。
</div>
<div class="noteHeading">
笔记 -  第 55 页
</div>
<div class="noteText">
Express 源码
</div>
<div class="sectionHeading">
7.2　选择模板引擎
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 62 页
</div>
<div class="noteText">
我强烈推荐你看看 Veena Basavaraj的博客文章（ http:// engineering. linkedin. com/ frontend/ client- side- templating- throwdown- mustache- handlebars- dustjs- and- more），那里有她为 LinkedIn选择模板引擎时的相关准则。
</div>
<div class="noteHeading">
笔记 -  第 62 页
</div>
<div class="noteText">
模板引擎选择的建议
</div>
<div class="sectionHeading">
7.4　Handlebars基础
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 63 页
</div>
<div class="noteText">
理解模板引擎的关键在于 context（上下文环境）。当你渲染一个模板时，便会传递给模板引擎一个对象，叫作上下文对象，它能让替换标识运行。
</div>
<div class="noteHeading">
笔记 -  第 63 页
</div>
<div class="noteText">
模板引擎上下文
</div>
<div class="sectionHeading">
7.4.8　完善你的模板
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 72 页
</div>
<div class="noteText">
Themeforest（ http:// themeforest. net/ category/ site- templates）和 WrapBootstrap（ https:// wrapbootstrap. com/）这样的网站有几百种 HTML5即用模板，它们可以用来开发你的第一个模板。
</div>
<div class="noteHeading">
笔记 -  第 73 页
</div>
<div class="noteText">
模板
</div>
<div class="sectionHeading">
8.1　向服务器发送客户端数据
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 76 页
</div>
<div class="noteText">
向服务器发送客户端数据有两种方式：查询字符串和请求正文。通常，如果是使用查询字符串，就发起了一个 GET请求；如果是使用请求正文，就发起了一个 POST请求（
</div>
<div class="noteHeading">
笔记 -  第 76 页
</div>
<div class="noteText">
向服务器发起客户端请求
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 76 页
</div>
<div class="noteText">
浏览器会限制查询字符串的长度（对请求正文没有长度限制）。基于这些原因，一般推荐使用 POST进行表单提交。
</div>
<div class="noteHeading">
笔记 -  第 76 页
</div>
<div class="noteText">
使用Post 请求提交表单的原因
</div>
<div class="sectionHeading">
8.4　处理表单的不同方式
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 78 页
</div>
<div class="noteText">
HTTP规范明确地表明浏览器 303重定向后，无论之前是什么方法，都应该使用 GET请求。这是用于响应表单提交请求的推荐方法。
</div>
<div class="noteHeading">
笔记 -  第 78 页
</div>
<div class="noteText">
相应表单请求的推荐方法
</div>
<div class="sectionHeading">
8.5　Express表单处理
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 79 页
</div>
<div class="noteText">
如果使用 POST（推荐使用的），需要引入中间件来解析 URL编码体。首先，安装 body- parser中间件（ npm install -- save body- parser），
</div>
<div class="noteHeading">
笔记 -  第 79 页
</div>
<div class="noteText">
Body -parse 中间件处理post 请求
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 81 页
</div>
<div class="noteText">
这种情况下使用 303（或 302）重定向，而不是 301重定向，这一点非常重要。 301重定向是“永久”的，意味着浏览器会缓存重定向目标。如果使用 301重定向并且试图第二次提交表单，浏览器会绕过整个/ process处理程序直接进入/ thank you页面，因为它正确地认为重定向是永久性的。另一方面， 303重定向告诉浏览器“是的，你的请求有效，可以在这里找到响应”，并且不会缓存重定向目标。
</div>
<div class="noteHeading">
笔记 -  第 81 页
</div>
<div class="noteText">
303 重定向与301重定向的区别
</div>
<div class="sectionHeading">
8.6　处理AJAX表单
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 82 页
</div>
<div class="noteText">
req. accepts(' json, html')询问最佳返回格式是 JSON还是 HTML：这可以根据 AcceptsHTTP头信息推断出来，它是浏览器提供的可读的、有序的响应类型列表。
</div>
<div class="noteHeading">
笔记 -  第 82 页
</div>
<div class="noteText">
Req.accepts 询问最佳返回格式
</div>
<div class="sectionHeading">
第 9 章　Cookie与会话
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 88 页
</div>
<div class="noteText">
HTTP是无状态协议。这就是说，当你在浏览器中加载页面，然后转到同一网站的另一页面时，服务器和浏览器都没有任何内在的方法可以认识到，这是同一浏览器访问同一网站。换一种说法， Web工作的方式就是在每个 HTTP请求中都要包含所有必要的信息，服务器才能满足这个请求。
</div>
<div class="noteHeading">
笔记 -  第 88 页
</div>
<div class="noteText">
Http 无状态协议
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 88 页
</div>
<div class="noteText">
cookie的想法很简单：服务器发送一点信息，浏览器在一段可配置的时期内保存它。发送哪些信息确实是由服务器来决定：通常只是一个唯一 ID号，标识特定浏览器，从而维持一个有状态的假象。
</div>
<div class="noteHeading">
笔记 -  第 88 页
</div>
<div class="noteText">
Cookie 工作模式
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 89 页
</div>
<div class="noteText">
用签名 cookie会有帮助（不管是用户修改的还是恶意 JavaScript修改的，这些篡改都会在签名 cookie中留下明显的痕迹），并且还可以设定选项指明 cookie只能由服务器修改。这些 cookie的用途会受限，但它们肯定更安全。
</div>
<div class="noteHeading">
笔记 -  第 89 页
</div>
<div class="noteText">
用签名cookie 更安全
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 89 页
</div>
<div class="noteText">
会话要依赖 cookie，
</div>
<div class="noteHeading">
笔记 -  第 89 页
</div>
<div class="noteText">
会话依赖cookie 
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 89 页
</div>
<div class="noteText">
当服务器希望客户端保存一个 cookie时，它会发送一个响应头 Set- Cookie，其中包含名称/值对。当客户端向服务器发送含有 cookie的请求时，它会发送多个请求头 Cookie，其中包含这些 cookie的值。
</div>
<div class="noteHeading">
笔记 -  第 89 页
</div>
<div class="noteText">
服务器和客户端互发cookie 的方式
</div>
<div class="sectionHeading">
9.1　凭证的外化
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 89 页
</div>
<div class="noteText">
cookie秘钥是一个字符串，服务器知道它是什么，它会在 cookie发送到客户端之前对 cookie加密。这是一个不需要记住的密码，所以可以是随机字符串。我一般用一个随机密码生成器（受 xkcd启发， http:// preshing. com/ 20110811/ xkcd- password- generator）来生成 cookie秘钥。
</div>
<div class="noteHeading">
笔记 -  第 89 页
</div>
<div class="noteText">
Cookie 密钥
</div>
<div class="sectionHeading">
9.4.1　内存存储
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 92 页
</div>
<div class="noteText">
首先安装 express- session（ npm install -- save express- session）。然后，在链入 cookie- parser之后链入 express- session：
</div>
<div class="noteHeading">
笔记 -  第 92 页
</div>
<div class="noteText">
Express 中session 和cookie 的引入顺序
</div>
<div class="sectionHeading">
9.5　用会话实现即显消息
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 94 页
</div>
<div class="noteText">
注意看如何用同一个处理器处理 AJAX提交（因为我们检查了 req. xhr），并且我们仔细地区分开了输入验证错误和数据库错误。记住，即便我们在前端做了输入验证（你应该这样做），在后台也应该再做一次，因为恶意用户能够绕过前端验证。
</div>
<div class="noteHeading">
笔记 -  第 94 页
</div>
<div class="noteText">
后台区分数据库错误和验证错误
</div>
<div class="sectionHeading">
第 10 章　中间件
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 96 页
</div>
<div class="noteText">
从概念上讲，中间件是一种功能的封装方式，具体来说就是封装在程序中处理 HTTP请求的功能。从实战上讲，中间件只是一个有 3个参数的函数：一个请求对象、一个响应对象和一个 next函数，稍后会作解释。（还有一种 4个参数的形式，用来做错误处理，这会在本章末尾讲到。）
</div>
<div class="noteHeading">
笔记 -  第 96 页
</div>
<div class="noteText">
中间件的简单概念
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 97 页
</div>
<div class="noteText">
路由处理器（ app. get、 app. post等，经常被统称为 app. VERB）可以被看作只处理特定 HTTP谓词（ GET、 POST等）的中间件。同样，也可以将中间件看作可以处理全部 HTTP谓词的路由处理器（基本上等同于 app. all，可以处理任何 HTTP谓词；对于 PURGE之类特别的谓词会有细微的差别，但对于普通的谓词而言，效果是一样的）。
</div>
<div class="noteHeading">
笔记 -  第 97 页
</div>
<div class="noteText">
路由处理器
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 97 页
</div>
<div class="noteText">
路由处理器和中间件的参数中都有回调函数，这个函数有 2个、 3个或 4个参数（从技术上讲也可以有 0或 1个参数，但这些形式没有意义）。如果有 2个或 3个参数，头两个参数是请求和响应对象，第三个参数是 next函数。如果有 4个参数，它就变成了错误处理中间件，第一个参数变成了错误对象，然后依次是请求、响应和 next对象。
</div>
<div class="noteHeading">
笔记 -  第 97 页
</div>
<div class="noteText">
路由处理器和中间件的参数
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 97 页
</div>
<div class="noteText">
如果不调用 next()，管道就会被终止，也不会再有处理器或中间件做后续处理。如果你不调用 next()，则应该发送一个响应到客户端（ res. send、 res. json、 res. render等）；如果你不这样做，客户端会被挂起并最终导致超时。如果调用了 next()，一般不宜再发送响应到客户端。如果你发送了，管道中后续的中间件或路由处理器还会执行，但它们发送的任何响应都会被忽略。
</div>
<div class="noteHeading">
笔记 -  第 97 页
</div>
<div class="noteText">
路由和中间件的next ()方法
</div>
<div class="sectionHeading">
10.1　常用中间件
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 101 页
</div>
<div class="noteText">
compress（ app. use( connect. compress);）用 gzip压缩响应数据。这是好事，用户会因此感激你的，特别是那些网络比较慢或者用手机上网的用户。它应该在任何可能会发送响应的中间件之前被尽早连入。唯一应该出现在 compress之前的中间件只有 debugging或 logging（它们不发送响应）。
</div>
<div class="noteHeading">
笔记 -  第 101 页
</div>
<div class="noteText">
后端压缩数据中间件
</div>
<div class="sectionHeading">
11.1　SMTP、MSA和MTA
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 103 页
</div>
<div class="noteText">
发送邮件的通用语言是简单邮件传输协议（ SMTP）。
</div>
<div class="noteHeading">
笔记 -  第 103 页
</div>
<div class="noteText">
Smtp 简单邮件传输协议
</div>
<div class="sectionHeading">
11.2　接收邮件
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 104 页
</div>
<div class="noteText">
需要这个功能，应该看看 Andris Reinman的 SimpleSMTP（ https:// github. com/ andris9/ simplesmtp）或 Haraka（ http:// haraka. github. io/）。
</div>
<div class="noteHeading">
笔记 -  第 104 页
</div>
<div class="noteText">
接受邮件参考
</div>
<div class="sectionHeading">
11.5　HTML邮件
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 105 页
</div>
<div class="noteText">
首先向你推荐 MailChimp关于如何编写 HTML邮件的优秀文章（ http:// kb. mailchimp. com/ campaigns/ ways- to- build/ how- to- code- html- emails）。它很好地囊括了编写 HTML邮件的基础知识，并解释了在写 HTML邮件时应该记住的事情。其次是 HTML Email Boilerplate（ http:// htmlemailboilerplate. com/），它真的能节省很多时间。它本质上是一个编写得非常良好并经过严格测试的 HTML邮件模板。
</div>
<div class="noteHeading">
笔记 -  第 105 页
</div>
<div class="noteText">
写HTML  邮件的建议
</div>
<div class="sectionHeading">
11.8.1　HTML邮件中的图片
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 109 页
</div>
<div class="noteText">
你最好在静态资源文件夹中给邮件图片一个专门的位置。你甚至应该把同时用在网站和邮件中的资源文件（比如你的日志）分开，这样会减小你的邮件布局受到负面影响的可能性。
</div>
<div class="noteHeading">
笔记 -  第 109 页
</div>
<div class="noteText">
处理邮件中使用静态资源的建议
</div>
<div class="sectionHeading">
12.3　扩展你的网站
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 115 页
</div>
<div class="noteText">
扩展是必不可少的。好在 Node对向外扩展
</div>
<div class="sectionHeading">
12.3.1　用应用集群扩展
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 116 页
</div>
<div class="noteText">
应用集群好在两个地方：第一，它有助于实现给定服务器性能的最大化（硬件或虚拟机）；第二，它是一种在并行条件下测试程序的低开销方式。
</div>
<div class="noteHeading">
笔记 -  第 116 页
</div>
<div class="noteText">
应用集群的好处
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 117 页
</div>
<div class="noteText">
脚本是另外一个脚本用 require加载进来的。然后我们会创建一个新脚本， meadowlark_ cluster. js： var cluster = require(' cluster');
</div>
<div class="sectionHeading">
12.3.2　处理未捕获的异常
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 119 页
</div>
<div class="noteText">
遇到未处理异常时，我们怎么才能尽可能正常地关闭服务器呢？ Node有两种机制解决这个问题： uncaughtException事件和域。
</div>
<div class="noteHeading">
笔记 -  第 119 页
</div>
<div class="noteText">
遇到未处理的异常node 的处理方式
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 121 页
</div>
<div class="noteText">
我强烈推荐你阅读 William Bert的优秀文章“ The 4 Keys to 100% Uptime with Node. js”（ http:// engineering. fluencia. com/ blog/ 2013/ 12/ 20/ the- 4- keys- to- 100- uptime- with- nodejs）。 William有在 Node上运行 Fluencia和 SpanishDict的经验，所以他是这方面的权威，并且他认为用域是保持 Node正常运行的根本。 Node关于域的官方文档（ http:// nodejs. org/ api/ domain. html）也值得通读。
</div>
<div class="noteHeading">
笔记 -  第 121 页
</div>
<div class="noteText">
了解node 域的资料
</div>
<div class="sectionHeading">
12.4.1　第三方正常运行监控
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 122 页
</div>
<div class="noteText">
监控。 UptimeRobot（ http:// uptimerobot. com/）有 50个免费监控，并且配置简单。警报可以通过邮件、短信（文本消息）、 Twitter或者 iPhone应用程序发送。你可以监控单个页面的返回码（除 200之外的所有返回码都可以视为错误），或者检查页面上有没有某个关键字。不过要记住，如果你用关键字监控，它可能会影响你的分析（你可以从大多数分析服务中去掉正常运行监控产生的流量）。
</div>
<div class="noteHeading">
笔记 -  第 122 页
</div>
<div class="noteText">
网站监控服务
</div>
<div class="sectionHeading">
12.5　压力测试
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 123 页
</div>
<div class="noteText">
用 Node模块 loadtest做压力测试：
</div>
<div class="noteHeading">
笔记 -  第 123 页
</div>
<div class="noteText">
Node 压力测试
</div>
<div class="sectionHeading">
13.3　数据库持久化
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 127 页
</div>
<div class="noteText">
两种最流行的 NoSQL数据库是文档数据库和键-值数据库。文档数据库善于存储对象，这使得它们非常适合 Node和 JavaScript。键-值数据库如其名所示，极其简单，对于数据模式可以轻松映射到键-值对的程序来说是很好的选择。
</div>
<div class="noteHeading">
笔记 -  第 127 页
</div>
<div class="noteText">
Nosql 数据库
</div>
<div class="sectionHeading">
13.3.7　获取数据
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 131 页
</div>
<div class="noteText">
< a href ="/ cart/ add? sku ={{ sku}}" class
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 133 页
</div>
<div class="noteText">
在某些 MVC架构的变体中，引入了一种称为“视图模型”的组件。视图模型本质上就是对模型的抽取和转换，从而让模型（或多个模型）更适合在视图中显示。我们上面做的基本上就是即时创建一个视图模型。
</div>
<div class="noteHeading">
笔记 -  第 133 页
</div>
<div class="noteText">
试图模型概念
</div>
<div class="sectionHeading">
13.3.9　用MongoDB存储会话数据
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 136 页
</div>
<div class="noteText">
MongoDB不一定是会话存储的最佳选择，它有点杀鸡用牛刀的意味。另外一个流行又易用的会话持久化方案是用 Redis（ http:// redis. io/）。请参阅 connect- redis包（ https:// www. npmjs. org/ package/ connect- redis）来了解如何设置使用 Redis做会话存储。
</div>
<div class="noteHeading">
笔记 -  第 136 页
</div>
<div class="noteText">
Redis 
</div>
<div class="sectionHeading">
第 14 章　路由
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 138 页
</div>
<div class="noteText">
绝不在 URL中暴露技术细节你有没有过这种经历：看到 URL以“. asp”结尾的网站，然后觉得那个网站过时到无可救药的地步了？记住，曾几何时， ASP是前沿技术。尽管说起来很痛苦，但 JavaScript、 JSON、 Node和 Express也会落得如此下场。希望很多很多年后才会如此，但时间对技术是无情的。避免在 URL中出现无意义的信息认真考虑 URL中的每个单词。如果它没有任何意义，就去掉它。比如说，当网站在 URL中使用单词 home时总会让我退缩。根路由就是首页。你不需要像/ home/ directions和/ home/ contact这样的 URL。
</div>
<div class="noteHeading">
笔记 -  第 138 页
</div>
<div class="noteText">
Url 准则1
</div>
<div class="noteHeading">
笔记 -  第 138 页
</div>
<div class="noteText">
Url 准则2
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 138 页
</div>
<div class="noteText">
避免无谓的长 URL在同等条件下，短的 URL比长的 URL好。然而你不应该为了缩短 URL牺牲清晰性，或者 SEO。缩写很诱人，但要认真考虑：在你把它们固定到 URL中之前，它们应该是非常常见和普遍的。
</div>
<div class="noteHeading">
笔记 -  第 138 页
</div>
<div class="noteText">
Url 准则3
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 138 页
</div>
<div class="noteText">
单词分隔符要保持一致用连字符分隔单词的情况十分常见，而用下划线的情况不太多。一般认为连字符比下划线更美观，并且大多数 SEO专家都建议用连字符。不管你选择用连字符还是用下划线，都要保持一致。
</div>
<div class="noteHeading">
笔记 -  第 138 页
</div>
<div class="noteText">
Url 准则4
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 138 页
</div>
<div class="noteText">
绝不要用空格或不可录入的字符不要在 URL中使用空格。它一般会被转换成加号（ +），会引起困惑。很明显你应该避免使用不可录入的字符，并且我要提醒你，一定不要使用除字母、数字、破折号和下划线之外的任何字符。用的时候你可能觉得很聪明，但“聪明”经受不住时间的检验。很明显，如果网站的受众用的不是英语，你可能会用非英文字符（会被转换成百分比码），但如果你要本地化，可能会觉得头疼。
</div>
<div class="noteHeading">
笔记 -  第 138 页
</div>
<div class="noteText">
Url 准则5
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 139 页
</div>
<div class="noteText">
在 URL中用小写字母这可能会引起争论：有些人觉得 URL中用混合大小写不仅是可以接受的，还应该优先使用。我不想挑起这种争论，但我要指出小写的好处，它总能由代码自动生成。如果你曾经要遍历网站净化上千个链接，或者做字符串比较，就会支持这种说法。我个人感觉小写字母的 URL更美观，但最终决定权在你。
</div>
<div class="noteHeading">
笔记 -  第 139 页
</div>
<div class="noteText">
Url 准则6
</div>
<div class="sectionHeading">
14.2　子域名
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 139 页
</div>
<div class="noteText">
用子域名分割内容时一般会影响 SEO，所以一般应该留给 SEO不重要的区域，比如管理区域和 API。记住
</div>
<div class="noteHeading">
笔记 -  第 139 页
</div>
<div class="noteText">
子域名影响seo 
</div>
<div class="sectionHeading">
14.6　组织路由
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 143 页
</div>
<div class="noteText">
给路由处理器用命名函数到目前为止，我们都是在行内写路由处理器的，实际上就是马上在那里定义处理路由的函数。这对于小程序或原型来说没问题，但随着网站的增长，这种方式很快就会变得过于笨重。路由不应该神秘这个原则故意说得比较模糊，因为大型的复杂网站可能比只有 10个页面的网站需要更加复杂的组织方案。一种极端的做法是简单地把网站的所有路由都放到一个文件中，好知道它们在哪。对于大型网站来说，你可能不想这样，那就根据功能区域把路由分开。然而，即便如此，也应该清楚该到哪里找给定的路由。当你需要修订错误时，肯定不想花上一个小时来确定那个路由是在哪里处理的。我手头有一个 ASP. NET MVC项目就有这种恐怖的问题：路由至少出现在 10个不同的地方，并且毫无逻辑可言，也不一致，经常是自相矛盾的。即便我对那个（非常大的）网站非常熟悉，也要花好多时间追踪某个路由是在哪里处理的。路由组织应该是可扩展的如果你现在有 20或 30个路由，把它们都放在一个文件中可能没问题。如果在 3年内你有了 200个路由呢？这是有可能的。不管你选择用什么办法，都应该确保有增长的空间。不要忽视自动化的基于视图的路由处理器如果你的网站由很多静态和固定 URL的页面组成，你的所有路由最终看起来将像是： app. get('/ static/ thing', function( req, res){ res. render(' static/ thing'); }。要减少不必要的重复代码，可以考虑使用自动化的基于视图的路由处理器。本章后面介绍了这种方式，并且它可以跟定制路由一起用。
</div>
<div class="noteHeading">
笔记 -  第 143 页
</div>
<div class="noteText">
组织路由的几个原则
</div>
<div class="sectionHeading">
14.9　自动化渲染视图
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 145 页
</div>
<div class="noteText">
比如说你想添加文件 views/ foo. handlebars，然后它就神奇地可以通过路由/ foo访问了。我们看看怎么做。在我们的应用程序文件中，就在 404处理器之前，添加下面的中间件： var autoViews = {}; var fs = require(' fs'); app. use( function( req, res, next){ var path = req. path. toLowerCase(); //检查缓存；如果它在那里，渲染这个视图 if( autoViews[ path]) return res. render( autoViews[ path]); //如果它不在缓存里，那就看看有没有. handlebars文件能匹配 if( fs. existsSync(__ dirname + '/ views' + path + '. handlebars')){ autoViews[ path] = path. replace(/ ^\//, ''); return res. render( autoViews[ path]); } //没发现视图；转到 404处理器 next(); });
</div>
<div class="noteHeading">
笔记 -  第 146 页
</div>
<div class="noteText">
自动化渲染视图
</div>
<div class="sectionHeading">
14.10　其他的路由组织方式
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 146 页
</div>
<div class="noteText">
最流行的两种路由组织方式是命名空间路由（ namespaced routing）和随机应变路由（ resourceful routing）。当很多路由都以相同的前缀开始时，命名空间路由很不错（比如/ vacations）。有个 Node模块叫 express- namespace，它让这种方式变得很容易。随机应变路由基于一个对象中的方法自动添加路由。如果网站的逻辑是天然面向对象的，这项技术就很好用。 express- resource包是如何实现这种路由组织风格的范例。
</div>
<div class="noteHeading">
笔记 -  第 146 页
</div>
<div class="noteText">
相关的其他组织路由的方式
</div>
<div class="sectionHeading">
第 15 章　REST API和JSON
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 147 页
</div>
<div class="noteText">
Web服务”是一个通用术语，指任何可以通过 HTTP访问的应用程序编程界面（ API）。
</div>
<div class="noteHeading">
笔记 -  第 147 页
</div>
<div class="noteText">
Web 服务 api 
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 147 页
</div>
<div class="noteText">
缩略词 REST表示“表述性状态传输”（ Representational State Transfer），念起来有点麻烦的“ REST风格”作为一个形容词来形容满足 REST原则的 Web服务。 REST的正规描述很复杂，需要计算机科学形式上的表述，但 REST基本上就是客户端和服务器端的无状态连接。 REST的正式定义还指出服务可以被缓存，可以被分层（即当你使用一个 REST API时，可能还有其他 REST API在它下面）。
</div>
<div class="noteHeading">
笔记 -  第 147 页
</div>
<div class="noteText">
 rest 概念
</div>
<div class="sectionHeading">
15.2　我们的API
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 149 页
</div>
<div class="noteText">
将 POST用于创建而 PUT用于更新（或修改），这已经成为标准了。这些单词的英文含义并不支持这种分别，所以你可能要考虑用路径来区分这两种操作以避免混淆。
</div>
<div class="noteHeading">
笔记 -  第 149 页
</div>
<div class="noteText">
Http 创建和更新的标准动词
</div>
<div class="sectionHeading">
15.4　跨域资源共享
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 150 页
</div>
<div class="noteText">
跨站 HTTP请求一直是很多攻击的对象，因此受到了同源策略的限制，限制可以从哪里加载脚本。具体来说就是协议、域和端口必须匹配。这使得其他网站不可能使用你的 API，所以有了跨域资源共享（ CORS）。 CORS允许你针对个案解除这个限制，甚至允许你列出具体哪些域可以访问这个脚本。 CORS是通过 Access- Control- Allow- Origin响应头实现的。在 Express程序中最容易的实现方式是用 cors包（ npm install -- save cors）。要在程序中启用 CORS： app. use( require(' cors')());
</div>
<div class="noteHeading">
笔记 -  第 150 页
</div>
<div class="noteText">
跨站http 请求
</div>
<div class="sectionHeading">
15.8　使用REST插件
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 153 页
</div>
<div class="noteText">
只用 Express写 API很容易。然而用 REST插件有些优势。接下来我们用健壮的 connect- rest让 API可以面向未来。
</div>
<div class="noteHeading">
笔记 -  第 153 页
</div>
<div class="noteText">
connect -reset 插件
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 153 页
</div>
<div class="noteText">
connect- rest模块会检查每一个请求，向请求对象中添加属性，还会做额外的日志记录。因此把它放在网站路由后面更好，但要在 404处理器之前：
</div>
<div class="noteHeading">
笔记 -  第 153 页
</div>
<div class="noteText">
connect-reset 的路由放置的位置
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 155 页
</div>
<div class="noteText">
REST函数不是只有常见的请求/响应两个参数，而是有三个：一个请求（跟平常一样）；一个内容对象，是请求被解析的主体；一个回调函数，可以用于异步 API的调用。
</div>
<div class="noteHeading">
笔记 -  第 155 页
</div>
<div class="noteText">
Rest 函数
</div>
<div class="sectionHeading">
15.9　使用子域名
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 155 页
</div>
<div class="noteText">
首先确保 vhost中间件已经装好了（ npm install -- save vhost）。在开发环境中，你可能没有自己的域名服务器（ DNS），所以我们需要用一种手段让 Express相信你连接了一个子域。为此需要向 hosts文件中添加一条记录。在 Linux和 OS X系统中， hosts文件是/ etc/ hosts；在 Windows中是% SystemRoot%\ system32\ drivers\ etc\ hosts。如果测试服务器的 IP地址是 192. 168. 0. 100，则在 hosts文件中添加下面这行记录： 192. 168. 0. 100 api. meadowlark
</div>
<div class="noteHeading">
笔记 -  第 155 页
</div>
<div class="noteText">
使用vhost 使用子域名提供网站api 
</div>
<div class="sectionHeading">
16.1　性能方面的考虑
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 158 页
</div>
<div class="noteText">
在性能上主要考虑两点：减少请求次数和缩减内容的大小。
</div>
<div class="noteHeading">
笔记 -  第 158 页
</div>
<div class="noteText">
处理静态资源性能上的考虑
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 158 页
</div>
<div class="noteText">
减少请求的次数：合并资源和浏览器缓存。
</div>
<div class="noteHeading">
笔记 -  第 158 页
</div>
<div class="noteText">
减少请求次数
</div>
<div class="sectionHeading">
16.2　面向未来的网站
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 159 页
</div>
<div class="noteText">
你的静态资源托管给内容发布网络（ CDN）。 CDN是专为提供静态资源而优化的服务器，它利用特殊的头信息（我们马上就会讲到）启用浏览器缓存。另外 CDN还能基于地理位置进行优化，也就是说它们可以从地理位置上更接近客户端的服务器发布静态内容。
</div>
<div class="noteHeading">
笔记 -  第 159 页
</div>
<div class="noteText">
Cdn
</div>
<div class="sectionHeading">
16.4　客户端JavaScript中的静态资源
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 163 页
</div>
<div class="noteText">
CART_ FULL ); });如果你要在客户端做很多的图片切换，可能要把所有图片变量放在一个对象中（它本身就成了一个映射）。比如可以这样重写前面的代码： <!-- ... -- > < script > var static = { IMG_ CART_ EMPTY: '{{ static '/ img/ shop/ cart_ empty. png'}}', IMG_ CART_ FULL: '{{ static '/ img/ shop/ cart_ full. png'}} } </ script > 16. 5 提供静态资源现在我们已经明白如何创建一个框架来轻松地修改静态资源的提供源了，那么究竟什么才是存储这些资产的最佳方式呢？
</div>
<div class="sectionHeading">
第 17 章　在Express中实现MVC
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 173 页
</div>
<div class="noteText">
在 MVC中，模型是“纯粹”的数据和逻辑。它根本不关心自己跟用户之间的交互。视图将模型传递给用户，而控制器则接受用户输入，处理模型，选择要显示哪个（些）视图。（我经常想，“调度器”应该比“控制器”更合适：毕竟，控制器听起来不像是会接受用户输入的东西，而在 MVC项目中这是控制器的一个主要责任。）
</div>
<div class="noteHeading">
笔记 -  第 173 页
</div>
<div class="noteText">
简单理解mvc
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 173 页
</div>
<div class="noteText">
视图模型的想法是说它是模型的转化。另外，单个视图模型可能由不止一个模型组成，或者是几个模型的部分，或者是单个模型的部分。乍一看可能觉得没必要搞那么复杂，但我发现这个概念很有价值。它的价值在于可以“保护”模型。在纯粹的 MVC中，它会引诱（甚至是强迫）你对模型做只对视图来说有必要的转换或改进。模型视图可以“解救”你：如果你需要一个只用来展示的数据视图，它就属于视图模型。跟其他任何模式一样，你必须决定在贯彻这一模式时要多严格。过于严格会导致为了边缘情况的“正确做法”做出英勇就义式的努力，而过于松散又会导致维护问题和技术债务问题。我倾向于尽可能地向严格那一面倾斜。幸好， MVC（及视图模型）提供了非常自然的职责区域，并且我发现极少能碰到这个模式无法轻松容纳的情况。 17. 1 模型对我来说，模型绝对是最最重要的组件。如果你的模型足够健壮并设计优良，你总能废掉表示层（或者添加一个额外的表示层）。可换个方向就困难多了：模型是项目的基石。千万不要用表示代码或用户交互代码污染了你的模型。即便它
</div>
<div class="noteHeading">
笔记 -  第 173 页
</div>
<div class="noteText">
视图模型概念
</div>
<div class="sectionHeading">
17.1　模型
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 174 页
</div>
<div class="noteText">
我建议你在项目中创建一个叫 models的子目录来存放模型。只要你有要实现的逻辑，或要存储的数据，都应该在 models目录下的文件里完成。
</div>
<div class="noteHeading">
笔记 -  第 174 页
</div>
<div class="noteText">
模型的具体目录
</div>
<div class="sectionHeading">
17.2　视图模型
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 175 页
</div>
<div class="noteText">
尽管我不想在面对“将模型直接传递给视图”这种问题时表现得太教条，但如果你只是因为要在视图中显示什么就忍不住要修改你的模型，那我肯定会建议你创建个视图模型。视图模型是保持模型抽象性的办法，同时还能为视图提供有意义的数据。
</div>
<div class="noteHeading">
笔记 -  第 175 页
</div>
<div class="noteText">
视图模型的存在价值
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 176 页
</div>
<div class="noteText">
视图模型的概念对于保护模型的完整性和范围是必不可少的。
</div>
<div class="noteHeading">
笔记 -  第 176 页
</div>
<div class="noteText">
视图模型的功能
</div>
<div class="sectionHeading">
17.3　控制器
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 177 页
</div>
<div class="noteText">
控制器负责处理用户交互，并根据用户交互选择恰当的视图来显示。听起来是不是很像请求路由？实际上，控制器和路由器之间唯一的区别是控制器一般会把相关功能归组。我们已经见过一些把相关路由分组的办法了，现在只是通过管它叫控制器来做得更正式。
</div>
<div class="noteHeading">
笔记 -  第 177 页
</div>
<div class="noteText">
控制器
</div>
<div class="sectionHeading">
18.1　HTTPS
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 180 页
</div>
<div class="noteText">
HTTPS协议基于服务器上的公钥证书，有时也叫 SSL证书。 SSL证书目前的标准格式是 X. 509。证书背后的思想是由证书颁发机构（ CA）发行证书。 CA让浏览器厂商能访问受信根证书。在你安装浏览器时，其中就包含这些受信根证书，并靠它们建立起 CA和浏览器之间的信任链。要用这个信任链，你的服务器必须使用由 CA颁发的证书。
</div>
<div class="noteHeading">
笔记 -  第 180 页
</div>
<div class="noteText">
Https 公钥证书
</div>
<div class="sectionHeading">
18.2　跨站请求伪造
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 187 页
</div>
<div class="noteText">
要防范 CSRF攻击，你必须想办法确保请求合法地来自你的网站。我们的做法是给浏览器传一个唯一的令牌。当浏览器提交表单时，服务器会进行检查，以确保令牌是匹配的。 csurf中间件负责令牌的创建和验证；你只需要确保令牌包含在到服务器的请求中。安装 csurf中间件（ npm install -- save csurf），然后引入它，添加一个令牌到 res. locals中： //这个必须放在 cookie- parser和 connect- session的引入之后 app. use( require(' csurf')()); app. use( function( req, res, next){ res. locals._ csrfToken = req. csrfToken(); next(); });
</div>
<div class="noteHeading">
笔记 -  第 187 页
</div>
<div class="noteText">
防范跨站请求伪造的方法之一
</div>
<div class="sectionHeading">
18.3.1　认证与授权
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 188 页
</div>
<div class="noteText">
认证是指验证用户的身份，即他们是自己所宣称的人。授权是指确定用户有哪些权力，可以访问、修改或查看什么。比如说，客户可能会授权允许访问他们的账号信息，草地鹨旅行社的员工得到授权可以访问其他人的账号信息或销售记录。
</div>
<div class="noteHeading">
笔记 -  第 188 页
</div>
<div class="noteText">
认证和授权
</div>
<div class="sectionHeading">
18.3.6　Passport
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 192 页
</div>
<div class="noteText">
图 18- 2 第三方认证流程细节图简单起见，我们用草地鹨旅行社代表你的应用， Facebook代表第三方认证机制。
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 194 页
</div>
<div class="noteText">
现在我们装上 Passport和 Facebook认证策略： npm install -- save passport passport- facebook
</div>
<div class="noteHeading">
笔记 -  第 194 页
</div>
<div class="noteText">
Passport 做第三方登陆认证
</div>
<div class="sectionHeading">
18.3.7　基于角色的授权
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 199 页
</div>
<div class="noteText">
调用 next(' route')不是执行路由中的 next处理器，它会跳过这个路由。
</div>
<div class="noteHeading">
笔记 -  第 199 页
</div>
<div class="noteText">
跳过路由
</div>
<div class="sectionHeading">
19.1.3　渲染推文
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 207 页
</div>
<div class="noteText">
promise是一种管理异步功能的技术。异步函数不会立即返回，但我们可以创建一个 promise，异步部分一完成就马上 resolve。我们将会用到 Q promises库（ https:// npmjs. org/ package/ q），所以你一定要运行 npm install -- save q，
</div>
<div class="noteHeading">
笔记 -  第 207 页
</div>
<div class="noteText">
Promise 库
</div>
<div class="sectionHeading">
20.1　调试的首要原则
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 219 页
</div>
<div class="noteText">
排除可能有很多种形态。这里有些常见的例子：系统化地注释掉或禁用代码块。编写能被单元测试覆盖的代码；单元测试本身提供了一个用于排除的框架。分析网络数据流，确定问题是出在客户端还是服务器端。测试系统中跟第一个相似但不同的部分。使用之前能用的输入，并一点一点地修改输入，直到问题呈现。用版本控制逐次回退，直到问题消失。 “模拟”功能以排除复杂子系统的干扰。
</div>
<div class="noteHeading">
笔记 -  第 219 页
</div>
<div class="noteText">
排除 bug 的方法
</div>
<div class="sectionHeading">
20.3　利用Node内置的调试器
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 220 页
</div>
<div class="noteText">
node debug meadowlark. js
</div>
<div class="noteHeading">
笔记 -  第 220 页
</div>
<div class="noteText">
Node 内置调试
</div>
<div class="sectionHeading">
20.4　Node探查器
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 223 页
</div>
<div class="noteText">
有时候你需要调试的是应用程序的设置（比如在你连接中间件到 Express中去的时候）。像我们之前那样运行调试器，在我们有机会设断点之前，一眨眼的工夫全都发生了。好在这有办法解决。只需要用-- debug- brk代替-- debug就行了： node -- debug- brk meadowlark. js
</div>
<div class="noteHeading">
笔记 -  第 223 页
</div>
<div class="noteText">
调试Node 设置
</div>
<div class="sectionHeading">
21.1.1　域名系统
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 227 页
</div>
<div class="noteText">
域名系统（ DNS）负责将域名映射到 IP地址。这个系统相当复杂，但作为站长，有些跟 DNS有关的知识你应该掌握。
</div>
<div class="noteHeading">
笔记 -  第 227 页
</div>
<div class="noteText">
Dns 的作用
</div>
<div class="sectionHeading">
21.1.7　部署
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 234 页
</div>
<div class="noteText">
建议将 production（如果你愿意的话，包括 staging分支）当作一次性的：它们实际上只是你的 master分支在不同时点的映像。如果你需要回滚修改，只需要在你的 production分支上做一次 git reset -- hard < old commit id >，然后 git push origin production -- force。这在本质上是“重写历史”，经常被教条式的 Git使用者描述为危险的或“高级的”行为。然而在这里绝对可以理解为 production是一个只读分支；开发人员决不能向它提交代码（重写历史会给你带来麻烦）。
</div>
<div class="noteHeading">
笔记 -  第 234 页
</div>
<div class="noteText">
Git 工作流推荐方式
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 235 页
</div>
<div class="noteText">
git pull的-- ff- only参数只允许快进 pull，防止自动合并或重订。如果你知道 pull是只快进的，可以忽略它，但如果你习惯那么做，绝不会不小心调用了合并或重订！
</div>
<div class="noteHeading">
笔记 -  第 235 页
</div>
<div class="noteText">
Git pull 的更安全命令
</div>
<div class="sectionHeading">
23.1　在线文档
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 247 页
</div>
<div class="noteText">
对于 JavaScript、 CSS和 HTML文档而言，无人能与 Mozilla开发者网络（ MDN， https:// developer. mozilla. org/）相媲美。
</div>
<div class="noteHeading">
笔记 -  第 247 页
</div>
<div class="noteText">
Mdn 文档很好
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 247 页
</div>
<div class="noteText">
但如果你刚接触 HTML5（或者即便不是），都应该看看 Mark Pilgrim的《深入 HTML5》（ http:// diveintohtml5. info/）。 WHATWG维护着一个卓越的 HTML5规范“活标准”（ https:// developers. whatwg. org/），如果我遇到实在难以回答的 HTML问题，一般会首先找它求助。最后， HTML和 CSS的官方规范在 W3C网站（ http:// www. w3. org/）上；上面的文档晦涩难懂，但有时候遇到非常困难的问题，它是你唯一的资源。
</div>
<div class="noteHeading">
笔记 -  第 247 页
</div>
<div class="noteText">
Html5资源
</div>
<div class="sectionHeading">
23.2　期刊
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) -  第 248 页
</div>
<div class="noteText">
JavaScript周刊（ http:// javascriptweekly. com/） Node周刊（ http:// nodeweekly. com/） HTML5周刊（ http:// html5weekly. com/）
</div>
<div class="noteHeading">
笔记 -  第 248 页
</div>
<div class="noteText">
资源周刊
</div>

        </div>
    </body>
</html>
