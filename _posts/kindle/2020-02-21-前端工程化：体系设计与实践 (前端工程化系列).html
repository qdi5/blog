<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                              "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" >
<html xmlns="http://www.w3.org/TR/1999/REC-html-in-xml" xml:lang="en"
	lang="en">
	<head>
                <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
                <!-- HTML5 -->
                <meta charset="UTF-8"/>
		<style type="text/css">
                    .bodyContainer {
    font-family: Arial, Helvetica, sans-serif;
    text-align: center;
    padding-left: 32px;
    padding-right: 32px;
}

.notebookFor {
    font-size: 18px;
    font-weight: 700;
    text-align: center;
    color: rgb(119, 119, 119);
    margin: 24px 0px 0px;
    padding: 0px;
}

.bookTitle {
    font-size: 32px;
    font-weight: 700;
    text-align: center;
    color: #333333;
    margin-top: 22px;
    padding: 0px;
}

.authors {
    font-size: 13px;
    font-weight: 700;
    text-align: center;
    color: rgb(119, 119, 119);
    margin-top: 22px;
    margin-bottom: 24px; 
    padding: 0px;
}

.citation {
    font-size: 16px;
    font-weight: 500;
    text-align: center;
    color: #333333;
    margin-top: 22px;
    margin-bottom: 24px;
    padding: 0px;
}

.sectionHeading {
    font-size: 24px;
    font-weight: 700;
    text-align: left;
    color: #333333;
    margin-top: 24px;
    padding: 0px;
}

.noteHeading {
    font-size: 18px;
    font-weight: 700;
    text-align: left;
    color: #333333;
    margin-top: 20px;
    padding: 0px;
}

.noteText {
    font-size: 18px;
    font-weight: 500;
    text-align: left;
    color: #333333;
    margin: 2px 0px 0px;
    padding: 0px;
}

.highlight_blue {
    color: rgb(178, 205, 251);
}

.highlight_orange {
    color: #ffd7ae;
}

.highlight_pink {
    color: rgb(255, 191, 206);
}

.highlight_yellow {
    color: rgb(247, 206, 0);
}

.notebookGraphic {
    margin-top: 10px;
    text-align: left;
}

.notebookGraphic img {
    -o-box-shadow:      0px 0px 5px #888;
    -icab-box-shadow:   0px 0px 5px #888;
    -khtml-box-shadow:  0px 0px 5px #888;
    -moz-box-shadow:    0px 0px 5px #888;
    -webkit-box-shadow: 0px 0px 5px #888;
    box-shadow:         0px 0px 5px #888; 
    max-width: 100%;
    height: auto;
}

hr {
    border: 0px none;
    height: 1px;
    background: none repeat scroll 0% 0% rgb(221, 221, 221);
}

		</style>
		<script type="text/javascript">
		    
		</script>
		<title></title>
	</head>
    <body>
        <div class="bodyContainer">
            <div class="notebookFor">
笔记本
</div>
<div class="bookTitle">
前端工程化：体系设计与实践 (前端工程化系列)
</div>
<div class="authors">
周俊鹏
</div>
<div class="citation">
Citation (MLA): 周俊鹏. <i>前端工程化：体系设计与实践 (前端工程化系列)</i>. 电子工业出版社, 2018. Kindle file.
</div>
<hr />

            <div class="sectionHeading">
第1章 前端工程简史
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.1 前端工程师的基本素养 >  位置 252
</div>
<div class="noteText">
数据结构、算法、软件工程等基础知识对于前端工程师同样重要，这些知识能够决定一个前端工程师的上限。
</div>
<div class="noteHeading">
笔记 - 1.1 前端工程师的基本素养 >  位置 253
</div>
<div class="noteText">
数据结构,算法,软件工程对于前端工程师的重要性
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.1 前端工程师的基本素养 >  位置 264
</div>
<div class="noteText">
●保证内容的快速展现，减少用户等待时间。 ●保证操作的流畅度。 ●如果是移动设备，应尽量减少设备的耗电量。
</div>
<div class="noteHeading">
笔记 - 1.1 前端工程师的基本素养 >  位置 266
</div>
<div class="noteText">
基本的用户体验
</div>
<div class="noteHeading">
笔记 - 1.1 前端工程师的基本素养 >  位置 286
</div>
<div class="noteText">
前端技术栈
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.1 前端工程师的基本素养 >  位置 286
</div>
<div class="noteText">
图
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.2 Node.js带给前端的改革 >  位置 321
</div>
<div class="noteText">
Node. js并非一个 JavaScript框架，而是一个集成了 Google V8 JavaScript引擎、事件驱动和底层 I/ O API，并且可使用 JavaScript语言开发服务器端应用的运行环境。与 PHP不同的是， Node. js可以直接提供网络服务，不需要借助 Apache、 Nginx等专业的服务器软件。
</div>
<div class="noteHeading">
笔记 - 1.2 Node.js带给前端的改革 >  位置 323
</div>
<div class="noteText">
Nodejs,是什么
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.2 Node.js带给前端的改革 >  位置 348
</div>
<div class="noteText">
●减轻了服务器的资源消耗。 ●与 HTML文档比起来， JSON数据的体积小很多，减少了网络请求的时间消耗。 ●页面路由控制更快速灵活。 ●可以离线使用。
</div>
<div class="noteHeading">
笔记 - 1.2 Node.js带给前端的改革 >  位置 350
</div>
<div class="noteText">
Spa,的好处
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.3 前后端分离 >  位置 377
</div>
<div class="noteText">
●从开发角度来讲，前后端分离的宗旨是实现并行开发，缩短开发周期。 ●从测试角度来讲，前后端分离令前端工程师和后端工程师更快速、精准地对问题进行定位。 ●从部署角度来讲，前后端分离将静态文件和动态文件分离部署并结合回滚策略，简化了部署流程，增强了应用程序的健壮性。
</div>
<div class="noteHeading">
笔记 - 1.3 前后端分离 >  位置 380
</div>
<div class="noteText">
前后端分离提升效率
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.3 前后端分离 >  位置 424
</div>
<div class="noteText">
之所以称为“大前端”而不是“全栈工程师”是因为大前端通常不接触数据库操作。大前端负责的并不是真正的 Web服务层，而是中间层。中间层的作用主要解决的就是 HTML的渲染，这也是为了实现前后端分离而探索出的一个模式。
</div>
<div class="noteHeading">
笔记 - 1.3 前后端分离 >  位置 426
</div>
<div class="noteText">
大前端概念
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.4 前端工程化 >  位置 494
</div>
<div class="noteText">
前端工程化的主要目标是解放生产力、提高生产效率。通过制定一系列的规范，借助工具和框架解决前端开发以及前后端协作开发过程中的痛点和难点问题。
</div>
<div class="noteHeading">
笔记 - 1.4 前端工程化 >  位置 495
</div>
<div class="noteText">
前端工程化的目的
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.4 前端工程化 >  位置 557
</div>
<div class="noteText">
将所有工具的功能进行整合并统一为规范的工具栈（请注意不是将工具整合，而是将功能整合），这就是前端工程化的第一步：构建。
</div>
<div class="noteHeading">
笔记 - 1.4 前端工程化 >  位置 558
</div>
<div class="noteText">
工程化第一步:构建
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.4 前端工程化 >  位置 594
</div>
<div class="noteText">
引入本地服务器后的开发流程如图 1- 8所示。
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.4 前端工程化 >  位置 608
</div>
<div class="noteText">
优化部署的基本原则是，确保单方问题的修复不需要调动多方资源。具体的解决方案就是静态资源与动态资源分离部署。动静态资源的分离部署可以解耦前后端工程师的部署行为，两者可以对自身的产出进行独立部署。减少了耦合工作，就提高了迭代和维护效率。同时，动静态资源分离部署也是 Web应用架构优化的一个必要策略。
</div>
<div class="noteHeading">
笔记 - 1.4 前端工程化 >  位置 611
</div>
<div class="noteText">
优化部署
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.4 前端工程化 >  位置 612
</div>
<div class="noteText">
分离部署对工作效率的提升主要体现在集成测试阶段。
</div>
<div class="noteHeading">
笔记 - 1.4 前端工程化 >  位置 612
</div>
<div class="noteText">
分离部署
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.4 前端工程化 >  位置 614
</div>
<div class="noteText">
前提是测试所用的静态资源服务器需要设置浏览器不使用缓存或者协商缓存策略，并且静态资源的 URL不添加版本号参数或者 hash文件指纹，这样在静态文件更新后刷新浏览器即可请求到最新的文件，无须清理浏览器缓存。
</div>
<div class="noteHeading">
笔记 - 1.4 前端工程化 >  位置 615
</div>
<div class="noteText">
分离部署
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.4 前端工程化 >  位置 618
</div>
<div class="noteText">
前端渲染的优点如下。 ●前端掌控路由，与传统的服务器端路由相比用户体验更佳。 ●可移植、可离线使用。 ●服务器端提供的是干净的数据接口，具备高度的可复用性。 ● HTML资源作为静态资源，易于部署。 ●前端工程师与后端工程师可以使用 Git、 SVN等工具分别维护独立的源代码，无须耦合。
</div>
<div class="noteHeading">
笔记 - 1.4 前端工程化 >  位置 623
</div>
<div class="noteText">
前端渲染的优点
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.4 前端工程化 >  位置 649
</div>
<div class="noteText">
前端工程化是一系列工具和规范的组合，规范为蓝本，工具为实现。其中规范又包括： ●项目文件的组织结构，比如使用目录名称区分源文件和目标文件。 ●源代码的开发范式，比如使用既定的模块化方案。 ●工具的使用规范，比如工程化自身的配置规范。 ●各阶段环境的依赖，比如部署功能的实现需要目标服务器提供 SSH权限。
</div>
<div class="noteHeading">
笔记 - 1.4 前端工程化 >  位置 654
</div>
<div class="noteText">
定义前端工程化
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.4 前端工程化 >  位置 670
</div>
<div class="noteText">
前端工程化的下一进化形态便豁然开朗了：集中管理的云平台。管理平台形态的工程化做到了以下几点。 ●淡化环境差异性，保证构建产出的一致性。 ●权限集中管理，提高安全性。 ●项目版本集中管理，便于危机处理，比如版本回滚等。
</div>
<div class="noteHeading">
笔记 - 1.4 前端工程化 >  位置 673
</div>
<div class="noteText">
前端工程化第二步、云平台
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.5 工程化方案架构 >  位置 714
</div>
<div class="noteText">
Boi是一款开源的前端工程化方案，读者可以在 GitHub（https：// github. com/ boijs/ boi）中获取其源码。
</div>
<div class="noteHeading">
笔记 - 1.5 工程化方案架构 >  位置 714
</div>
<div class="noteText">
Bio 前端工程化方案
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 1.5 工程化方案架构 >  位置 728
</div>
<div class="noteText">
使用 commander. js定制具体的子命令了。
</div>
<div class="noteHeading">
笔记 - 1.5 工程化方案架构 >  位置 728
</div>
<div class="noteText">
Commander.js
</div>
<div class="sectionHeading">
第2章 脚手架
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 2.1 脚手架的功能和本质 >  位置 816
</div>
<div class="noteText">
脚手架的功能和本质：脚手架的功能是创建项目初始文件，本质是方案的封装。
</div>
<div class="noteHeading">
笔记 - 2.1 脚手架的功能和本质 >  位置 817
</div>
<div class="noteText">
脚手架的意义
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 2.2 脚手架在前端工程中的角色和特征 >  位置 845
</div>
<div class="noteText">
脚手架工具要解决的最切实问题，简单概括就是： ●快速生成配置。 ●降低框架学习成本。 ●令业务开发人员关注业务逻辑本身。
</div>
<div class="noteHeading">
笔记 - 2.2 脚手架在前端工程中的角色和特征 >  位置 848
</div>
<div class="noteText">
脚手架解决的问题
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 2.2 脚手架在前端工程中的角色和特征 >  位置 863
</div>
<div class="noteText">
这一阶段的工程化没有集成平台环境，脚手架、开发、本地服务器、构建以及部署测试功能模块全部在本地环境下执行。图 2- 3云管理平台以及持续集成阶段的工程化方案新增了集成平台环境，将构建与部署测试功能模块部署到云平台。
</div>
<div class="sectionHeading">
第3章 构建
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.3 ECMAScript与Babel >  位置 1230
</div>
<div class="noteText">
Babel的作用简单概括就是将浏览器未实现的 ECMAScript规范语法转化为可运行的低版本语法，
</div>
<div class="noteHeading">
笔记 - 3.3 ECMAScript与Babel >  位置 1230
</div>
<div class="noteText">
Babel 的作用
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.3 ECMAScript与Babel >  位置 1244
</div>
<div class="noteText">
狭义上的编译指的是，将由高级编程语言编写的源程序翻译成计算机可识别的二进制语言。宏观地讲，将目标环境不识别的源程序翻译成可识别程序的过程都可以称为编译。
</div>
<div class="noteHeading">
笔记 - 3.3 ECMAScript与Babel >  位置 1245
</div>
<div class="noteText">
编译的概念
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.3 ECMAScript与Babel >  位置 1251
</div>
<div class="noteText">
PostCSS反其道而行之，鼓励开发人员直接编写规范的 CSS源码，把 hack、 sprites等工作交给 PostCSS，
</div>
<div class="noteHeading">
笔记 - 3.3 ECMAScript与Babel >  位置 1252
</div>
<div class="noteText">
Postcss
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.3 ECMAScript与Babel >  位置 1279
</div>
<div class="noteText">
babel- preset- env插件可以将 ES6 Module语法转化为其他模块化规范，比如 AMD和 CommonJS等，默认情况下转化为 CommonJS。结合 webpack和 babel- loader进行编译时务必将此配置项设置为 false，否则会影响 webpack自身的编译功能。
</div>
<div class="noteHeading">
笔记 - 3.3 ECMAScript与Babel >  位置 1281
</div>
<div class="noteText">
Webpack 结合Babel 需要注意的问题
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.3 ECMAScript与Babel >  位置 1292
</div>
<div class="noteText">
使用. babelrc文件取代 webpack配置中 babel- loader的 options。
</div>
<div class="noteHeading">
笔记 - 3.3 ECMAScript与Babel >  位置 1293
</div>
<div class="noteText">
Vue 配置Babel 
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.4 CSS预编译与PostCSS >  位置 1341
</div>
<div class="noteText">
是将 CSS预编译与 PostCSS综合在一起。 ●使用 CSS预编译弥补 CSS源码的弱编程能力，比如变量、运算、继承、模块化等。 ●使用 PostCSS处理针对浏览器的需求，比如 autoprefix、自动 CSS Sprites等。
</div>
<div class="noteHeading">
笔记 - 3.4 CSS预编译与PostCSS >  位置 1344
</div>
<div class="noteText">
CSs预编译与postcSs 结合使用
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.4 CSS预编译与PostCSS >  位置 1360
</div>
<div class="noteText">
实现角度来讲需要考虑以下几点。 1）如何区分 CSS中引用的图片是否为可合并的散列图标？为何部分 DOM使用的背景图片不需要合并为 Sprites图片？ 2）如何处理多页面项目中为各页面独立生成 Sprites图片？为何项目中两个页面 home和 auth各有独立的图标集，需要生成 home. icons. png以及 auth. icons. png？ 3）如何处理为适配多种分辨率屏幕生成不同分辨率的 Sprites图片？比如有普通 Sprites图片 app. icons. png，另外需要生成针对高清屏幕的 app. icons@ 2x. png以及 app. icons@ 3x. png的 Sprites图片。
</div>
<div class="noteHeading">
笔记 - 3.4 CSS预编译与PostCSS >  位置 1366
</div>
<div class="noteText">
webpack 自动生成雪碧图需要考虑的问题
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.4 CSS预编译与PostCSS >  位置 1385
</div>
<div class="noteText">
自动生成 CSS Sprites功能实现借助于 PostCSS的插件 postcss- sprites，
</div>
<div class="noteHeading">
笔记 - 3.4 CSS预编译与PostCSS >  位置 1385
</div>
<div class="noteText">
使用Post cSs 插件实现雪碧图
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.5 模块化开发 >  位置 1417
</div>
<div class="noteText">
模块是一个白盒，侧重的是对属性的封装，重心在设计和开发阶段，不关注运行时逻辑；组件是一个可以独立部署的软件单元，面向的是运行时，侧重于产品的功能性。组件是一个黑盒，内部的逻辑是不可见的。模块可以理解为零件，比如轮胎上的螺丝钉；而组件则是轮胎，是具备某项完整功能的一个整体。具体到前端领域，一个 button是一个模块，一个包括多个 button的导航栏是一个组件。模块和组件的争论由来已久，
</div>
<div class="noteHeading">
笔记 - 3.5 模块化开发 >  位置 1421
</div>
<div class="noteText">
模块与组件
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.5 模块化开发 >  位置 1431
</div>
<div class="noteText">
模块化开发的价值有以下几点。 1）避免命名冲突。 2）便于依赖管理。 3）利于性能优化。 4）提高可维护性。 5）利于代码复用。
</div>
<div class="noteHeading">
笔记 - 3.5 模块化开发 >  位置 1435
</div>
<div class="noteText">
模块化开发的优点
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.5 模块化开发 >  位置 1463
</div>
<div class="noteText">
依赖管理是模块化规范的核心特性之一，开发者遵循既定的规范进行各模块之间的源代码编写，构建工具按照模块化规范对代码进行解析，生成 AST（ Abstract Syntax Tree，抽象语法树）获取各模块之间详细的依赖关系。 HTML文档只需要引入一个入口文件即可。
</div>
<div class="noteHeading">
笔记 - 3.5 模块化开发 >  位置 1466
</div>
<div class="noteText">
依赖管理
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.6 增量更新与缓存 >  位置 1557
</div>
<div class="noteText">
前端工程师所接触的主要是针对客户端浏览器的缓存策略，客户端的缓存可以分为以下两种。 1）利用本地存储，比如 LocalStorage、 SessionStorage等。 2）利用 HTTP缓存策略，其中又分为强制缓存与协商缓存。
</div>
<div class="noteHeading">
笔记 - 3.6 增量更新与缓存 >  位置 1559
</div>
<div class="noteText">
客户端缓存
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.6 增量更新与缓存 >  位置 1567
</div>
<div class="noteText">
浏览器对静态资源的缓存本质上是 HTTP协议的缓存策略，其中又可以分为强制缓存和协商缓存。两种缓存策略都会将资源缓存到本地，强制缓存策略根据过期时间决定使用本地缓存还是请求新资源；而协商缓存每次都会发出请求，经过服务器进行对比后决定采用本地缓存还是新资源。具体采用哪种缓存策略，由 HTTP协议的首部（ Headers）信息决定。
</div>
<div class="noteHeading">
笔记 - 3.6 增量更新与缓存 >  位置 1570
</div>
<div class="noteText">
http 缓存策略
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.6 增量更新与缓存 >  位置 1572
</div>
<div class="noteText">
Expires和 max- age是强制缓存策略的关键信息，两者均是响应首部信息的。
</div>
<div class="noteHeading">
笔记 - 3.6 增量更新与缓存 >  位置 1572
</div>
<div class="noteText">
Http 请求头的关键信息
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.6 增量更新与缓存 >  位置 1590
</div>
<div class="noteText">
max- age：指定从请求的时刻开始计算，此响应的缓存副本有效的最长时间（单位：秒）。例如，“ max- age = 3600”表示浏览器在接下来的 1小时内使用此响应的本地缓存，不会发送实体请求到服务器。
</div>
<div class="noteHeading">
笔记 - 3.6 增量更新与缓存 >  位置 1591
</div>
<div class="noteText">
Http 请求头max-age
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.6 增量更新与缓存 >  位置 1596
</div>
<div class="noteText">
Etag是服务器为资源分配的字符串形式唯一性标识，作为响应首部信息返回给浏览器。
</div>
<div class="noteHeading">
笔记 - 3.6 增量更新与缓存 >  位置 1597
</div>
<div class="noteText">
Http etag 信息
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.6 增量更新与缓存 >  位置 1651
</div>
<div class="noteText">
对于按需加载需求和在多模块架构场景下实现增量更新，需要考虑以下几个问题。 1）同步模块的修改对异步文件和主文件 hash指纹产生的影响。 2）异步模块的修改对主文件 hash指纹产生的影响。
</div>
<div class="noteHeading">
笔记 - 3.6 增量更新与缓存 >  位置 1653
</div>
<div class="noteText">
按需加载和增量更新需要注意的问题
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.6 增量更新与缓存 >  位置 1688
</div>
<div class="noteText">
Chunk在 webpack中的含义可以简单地理解为散列模块经合并后的“块”，
</div>
<div class="noteHeading">
笔记 - 3.6 增量更新与缓存 >  位置 1689
</div>
<div class="noteText">
Webpack chunk 理解
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.7 资源定位 >  位置 1736
</div>
<div class="noteText">
Web项目中的资源定位指的是存在引用关系的资源之间被引用方地址的改动都会被及时同步到引用方。具体到构建系统还有另外一层含义：以引用方为入口寻找被引用方并且进行构建。
</div>
<div class="noteHeading">
笔记 - 3.7 资源定位 >  位置 1738
</div>
<div class="noteText">
Web 资源定位
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.7 资源定位 >  位置 1755
</div>
<div class="noteText">
CDN（ Content Delivery Network，内容分发网络）是一种部署策略，包括分布式存储、负载均衡、内容管理等模块。
</div>
<div class="noteHeading">
笔记 - 3.7 资源定位 >  位置 1755
</div>
<div class="noteText">
Cdn 概念
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.7 资源定位 >  位置 1757
</div>
<div class="noteText">
CDN的一个重要功能是将静态资源缓存到用户近距离的 CDN节点上，不但能提高用户对静态资源的访问速度，还能节省服务器的带宽消耗、降低负载。
</div>
<div class="noteHeading">
笔记 - 3.7 资源定位 >  位置 1758
</div>
<div class="noteText">
Cdn 的一个重要功能
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 3.7 资源定位 >  位置 1893
</div>
<div class="noteText">
必须弄清楚两个重要的对象—— compiler和 compilation。 ● compiler对象代表的是 webpack执行环境的完整配置，只会在启动 webpack时被创建，并且在 webpack运行期间不会被修改。 ● compilation对象代表某个版本的资源对应的编译进程。当使用 webpack的 development中间件时，每次检测到项目文件有改动就会创建一个 compilation，进而能够针对改动生产全新的编译文件。 compilation对象包含当前模块资源、待编译文件、有改动的文件和监听依赖的所有信息。你可以将 compiler简单理解为不变的 webpack执行环境和配置，是面向 webpack的，与构建的项目文件无关；而 compilation是面向动态可变的项目文件，只要有改动就会被重新创建和执行。
</div>
<div class="noteHeading">
笔记 - 3.7 资源定位 >  位置 1898
</div>
<div class="noteText">
编写webpack 需要理解的两个信息
</div>
<div class="noteHeading">
笔记 - 3.7 资源定位 >  位置 1900
</div>
<div class="noteText">
理解 webpack 的两个重要信息
</div>
<div class="sectionHeading">
第4章 本地开发服务器
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 4.1 本地开发服务器解决的问题 >  位置 2019
</div>
<div class="noteText">
动态构建和 Mock服务是本地开发服务器的主要功能。动态构建解决的问题是面向开发层面的，通过监听 →修改 →触发 →构建的流程避免了源码的每次修改都需要人为地执行一次构建，便于开发过程中的即时调试。 Mock服务解决的问题是面向前后端协作层面的，以提前约定好的规范为前提，通过本地服务容器提供的 Mock数据接口辅助前端逻辑的编写。
</div>
<div class="noteHeading">
笔记 - 4.1 本地开发服务器解决的问题 >  位置 2022
</div>
<div class="noteText">
动态构建和mock 服务
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 4.1 本地开发服务器解决的问题 >  位置 2041
</div>
<div class="noteText">
Mock服务能够发挥作用的必要前提是前后端开发人员在正式进入开发之前协商好数据接口的规范，
</div>
<div class="noteHeading">
笔记 - 4.1 本地开发服务器解决的问题 >  位置 2042
</div>
<div class="noteText">
使用MOCK 的前提
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 4.2 动态构建 >  位置 2062
</div>
<div class="noteText">
中间件是在输入到输出过程中对内容进行加工从而输出预想的数据。
</div>
<div class="noteHeading">
笔记 - 4.2 动态构建 >  位置 2063
</div>
<div class="noteText">
中间件概念的简单理解
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 4.2 动态构建 >  位置 2089
</div>
<div class="noteText">
浏览器并不会在接收到绘制需求时便立即执行，而是将 1秒（ 1000毫秒）平均分为 60帧，每 1帧的绘制间隔约为 16. 7毫秒。
</div>
<div class="noteHeading">
笔记 - 4.2 动态构建 >  位置 2090
</div>
<div class="noteText">
浏览器绘制动画过程
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 4.2 动态构建 >  位置 2118
</div>
<div class="noteText">
Livereload的原理是在浏览器和服务器之间创建 WebSocket连接，服务器端在执行完动态编译之后发送 reload事件至浏览器，浏览器接收到此事件之后刷新整个页面，
</div>
<div class="noteHeading">
笔记 - 4.2 动态构建 >  位置 2119
</div>
<div class="noteText">
Live Reload 的原理
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 4.2 动态构建 >  位置 2141
</div>
<div class="noteText">
HMR热更新的流程如图 4- 3所示。
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 4.2 动态构建 >  位置 2143
</div>
<div class="noteText">
1）修改源文件并保存后， webpack监听到 Filesystem Event事件并触发了重新构建行为。 2）构建完成之后， webpack将模块变动信息传递给 HMR Server。 3） HMR Server通过 WebSocket发送 Push信息告知 HMR Runtime需要更新客户端模块， HMR Runtime随后通过 HTTP获取待更新模块的内容详情。 4）最终， HMR Runtime将更新的模块进行替换，在此过程中浏览器不会进行刷新。
</div>
<div class="noteHeading">
笔记 - 4.2 动态构建 >  位置 2147
</div>
<div class="noteText">
Webpack hmr 原理
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 4.3 Mock服务 >  位置 2188
</div>
<div class="noteText">
Mock进化的第二种形态是以 Mock. js为代表的客户端 Mock，工作原理是在客户端拦截 JavaScript代码发出的 AJAX请求并返回由 Mock. js创建的假数据。如下：
</div>
<div class="noteHeading">
笔记 - 4.3 Mock服务 >  位置 2190
</div>
<div class="noteText">
Mock 工作原理
</div>
<div class="sectionHeading">
第5章 部署
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 4.3 Mock服务 >  位置 2316
</div>
<div class="noteText">
本章从前端的角度剖析部署流程中需要注意的问题，主要包括以下内容。 ●部署流程的设计原则及解决思路。 ●前端静态资源的部署策略。
</div>
<div class="noteHeading">
笔记 - 4.3 Mock服务 >  位置 2318
</div>
<div class="noteText">
前端的角度剖析部署
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 5.1 部署流程的设计原则 >  位置 2328
</div>
<div class="noteText">
仿真生产环境以及灰度发布环境。在这样的团队中，任何一个微小
</div>
<div class="noteHeading">
标注 (<span class="highlight_yellow">黄色</span>) - 5.1 部署流程的设计原则 >  位置 2349
</div>
<div class="noteText">
1.可配置化。部署的目标服务器、路径信息应该与项目一一对应，并且可供负责部署的人员进行配置。 2.操作简化。部署行为（请注意是部署行为而非部署流程）的操作应该足够简单，而不应该像 FTP工具一样每次部署都需要按照“打开工具 →连接服务器 →定位路径 →上传文件”的流程进行手动操作。
</div>
<div class="noteHeading">
笔记 - 5.1 部署流程的设计原则 >  位置 2353
</div>
<div class="noteText">
部署工具的要求
</div>

        </div>
    </body>
</html>
